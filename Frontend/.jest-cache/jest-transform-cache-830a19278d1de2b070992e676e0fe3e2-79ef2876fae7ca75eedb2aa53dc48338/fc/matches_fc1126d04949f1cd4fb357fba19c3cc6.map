{"file":"/Users/admin/Documents/AI4Devs-finalproject/Frontend/src/api/matches.ts","mappings":";;;;;;AAAA,kDAA0B;AAC1B,+CAA+C;AAC/C,gCAA6B;AAW7B,MAAM,UAAU,GAAG,eAAK,CAAC,MAAM,CAAC;IAC9B,OAAO,EAAE,SAAG,CAAC,kBAAkB;CAChC,CAAC,CAAC;AAEH,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE;IACnD,MAAM,QAAQ,GAAG,IAAA,sBAAW,GAAE,CAAC;IAC/B,IAAI,QAAQ,EAAE,CAAC;QACb,IAAI,CAAC;YACH,MAAM,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAChC,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC,CAAA,CAAC;QACd,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;QAC7B,IAAI,KAAK,EAAE,CAAC;YACV,MAAM,CAAC,OAAO,CAAC,aAAa,GAAG,UAAU,KAAK,EAAE,CAAC;QACnD,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC,CAAC;AAEH,MAAa,cAAc;IACzB;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,MAAyB;QAChD,MAAM,YAAY,GAAG,IAAI,eAAe,EAAE,CAAC;QAE3C,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC;YACrB,YAAY,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;QACrD,CAAC;QAED,4GAA4G;QAC5G,IAAI,MAAM,CAAC,iBAAiB,EAAE,CAAC;YAC7B,YAAY,CAAC,MAAM,CAAC,mBAAmB,EAAE,MAAM,CAAC,iBAAiB,CAAC,CAAC;QACrE,CAAC;QACD,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;YACxB,YAAY,CAAC,MAAM,CAAC,cAAc,EAAE,MAAM,CAAC,YAAY,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC;YAChB,YAAY,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;QAC3C,CAAC;QAED,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;YAClB,YAAY,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;QAC/C,CAAC;QAED,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,GAAG,CAAa,YAAY,YAAY,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QACzF,OAAO,QAAQ,CAAC,IAAI,CAAC;IACvB,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,YAAY;QACvB,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,GAAG,CAAa,qBAAqB,CAAC,CAAC;QACzE,OAAO,QAAQ,CAAC,IAAI,CAAC;IACvB,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,EAAU;QAClC,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,GAAG,CAAW,YAAY,EAAE,EAAE,CAAC,CAAC;QAClE,OAAO,QAAQ,CAAC,IAAI,CAAC;IACvB,CAAC;CACF;AA9CD,wCA8CC","names":[],"sources":["/Users/admin/Documents/AI4Devs-finalproject/Frontend/src/api/matches.ts"],"sourcesContent":["import axios from 'axios';\nimport { getKeycloak } from '../auth/keycloak';\nimport { env } from '../env';\nimport type { MatchDto } from '../types/api';\n\nexport interface MatchSearchParams {\n  destinationSedeId?: string;\n  originSedeId?: string;\n  direction?: 'TO_SEDE' | 'FROM_SEDE';\n  time?: string;\n  origin?: string;\n}\n\nconst matchesApi = axios.create({\n  baseURL: env.matchingApiBaseUrl,\n});\n\nmatchesApi.interceptors.request.use(async (config) => {\n  const keycloak = getKeycloak();\n  if (keycloak) {\n    try {\n      await keycloak.updateToken(5);\n    } catch (_) {}\n    const token = keycloak.token;\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n  }\n  return config;\n});\n\nexport class MatchesService {\n  /**\n   * Find matches for a specific destination and criteria\n   */\n  static async findMatches(params: MatchSearchParams): Promise<MatchDto[]> {\n    const searchParams = new URLSearchParams();\n\n    if (params.direction) {\n      searchParams.append('direction', params.direction);\n    }\n\n    // Depending on direction, one sedeId is required. Keep backward compatibility when only destination is used\n    if (params.destinationSedeId) {\n      searchParams.append('destinationSedeId', params.destinationSedeId);\n    }\n    if (params.originSedeId) {\n      searchParams.append('originSedeId', params.originSedeId);\n    }\n\n    if (params.time) {\n      searchParams.append('time', params.time);\n    }\n\n    if (params.origin) {\n      searchParams.append('origin', params.origin);\n    }\n\n    const response = await matchesApi.get<MatchDto[]>(`/matches?${searchParams.toString()}`);\n    return response.data;\n  }\n\n  /**\n   * Get matches for the current user\n   */\n  static async getMyMatches(): Promise<MatchDto[]> {\n    const response = await matchesApi.get<MatchDto[]>('/matches/my-matches');\n    return response.data;\n  }\n\n  /**\n   * Get a specific match by ID\n   */\n  static async getMatchById(id: string): Promise<MatchDto> {\n    const response = await matchesApi.get<MatchDto>(`/matches/${id}`);\n    return response.data;\n  }\n}\n"],"version":3}