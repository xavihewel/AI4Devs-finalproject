b6f53e55984c886e8aa605dbadb0c542
"use strict";
/**
 * API client for routing operations.
 * Follows Single Responsibility Principle: only handles routing API calls.
 * Follows Dependency Inversion Principle: depends on abstractions (fetch).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.routingApiService = exports.RoutingApiService = void 0;
/**
 * Service for fetching routing information from backend API.
 * Implements caching to reduce API calls and improve performance.
 * Follows Open/Closed Principle: extensible for new routing features.
 */
class RoutingApiService {
    constructor(baseUrl = '/api') {
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.baseUrl = baseUrl;
    }
    /**
     * Get route between two points.
     * Returns cached result if available, otherwise fetches from API.
     * Follows Strategy Pattern: can be extended with different routing strategies.
     */
    async getRoute(origin, destination) {
        const cacheKey = this.createCacheKey(origin, destination);
        // Check cache first
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        try {
            const response = await fetch(`${this.baseUrl}/routes`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    origin,
                    destination,
                }),
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP ${response.status}`);
            }
            const routeData = await response.json();
            // Cache successful response
            this.cache.set(cacheKey, routeData);
            return routeData;
        }
        catch (error) {
            console.error('Error fetching route:', error);
            // Return fallback route (straight line)
            return this.createFallbackRoute(origin, destination);
        }
    }
    /**
     * Clear the route cache (useful for testing).
     */
    clearCache() {
        this.cache.clear();
    }
    /**
     * Create cache key from coordinates.
     * Follows Value Object pattern: immutable key generation.
     */
    createCacheKey(origin, destination) {
        return `${origin.lat.toFixed(6)},${origin.lng.toFixed(6)}->${destination.lat.toFixed(6)},${destination.lng.toFixed(6)}`;
    }
    /**
     * Create a simple straight-line fallback route when API fails.
     * Follows Fallback Strategy pattern.
     */
    createFallbackRoute(origin, destination) {
        const distance = this.calculateHaversineDistance(origin, destination);
        const duration = distance / 13.89; // Assume 50 km/h = 13.89 m/s average speed
        return {
            type: 'FeatureCollection',
            features: [
                {
                    type: 'Feature',
                    properties: {
                        distance,
                        duration,
                    },
                    geometry: {
                        type: 'LineString',
                        coordinates: [
                            [origin.lat, origin.lng],
                            [destination.lat, destination.lng],
                        ],
                    },
                },
            ],
        };
    }
    /**
     * Calculate distance between two points using Haversine formula.
     * Returns distance in meters.
     */
    calculateHaversineDistance(origin, destination) {
        const R = 6371000; // Earth radius in meters
        const dLat = this.toRadians(destination.lat - origin.lat);
        const dLng = this.toRadians(destination.lng - origin.lng);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(this.toRadians(origin.lat)) * Math.cos(this.toRadians(destination.lat)) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    /**
     * Convert degrees to radians.
     */
    toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }
}
exports.RoutingApiService = RoutingApiService;
// Singleton instance for the application
exports.routingApiService = new RoutingApiService();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9BSTREZXZzLWZpbmFscHJvamVjdC9Gcm9udGVuZC9zcmMvYXBpL3JvdXRpbmcudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7O0dBSUc7OztBQXFDSDs7OztHQUlHO0FBQ0gsTUFBYSxpQkFBaUI7SUFJNUIsWUFBWSxVQUFrQixNQUFNO1FBSDVCOzs7O21CQUFvQyxJQUFJLEdBQUcsRUFBRTtXQUFDO1FBQ3JDOzs7OztXQUFnQjtRQUcvQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBYyxFQUFFLFdBQW1CO1FBQ2hELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRTFELG9CQUFvQjtRQUNwQixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDN0IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUUsQ0FBQztRQUNuQyxDQUFDO1FBRUQsSUFBSSxDQUFDO1lBQ0gsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxTQUFTLEVBQUU7Z0JBQ3JELE1BQU0sRUFBRSxNQUFNO2dCQUNkLE9BQU8sRUFBRTtvQkFDUCxjQUFjLEVBQUUsa0JBQWtCO2lCQUNuQztnQkFDRCxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQztvQkFDbkIsTUFBTTtvQkFDTixXQUFXO2lCQUNaLENBQUM7YUFDSCxDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUNqQixNQUFNLFNBQVMsR0FBZSxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDcEQsTUFBTSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxJQUFJLFFBQVEs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LEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pELE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNLLFNBQVMsQ0FBQyxPQUFlO1FBQy9CLE9BQU8sT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNuQyxDQUFDO0NBQ0Y7QUFySEQsOENBcUhDO0FBRUQseUNBQXlDO0FBQzVCLFFBQUEsaUJBQWlCLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvQUk0RGV2cy1maW5hbHByb2plY3QvRnJvbnRlbmQvc3JjL2FwaS9yb3V0aW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQVBJIGNsaWVudCBmb3Igcm91dGluZyBvcGVyYXRpb25zLlxuICogRm9sbG93cyBTaW5nbGUgUmVzcG9uc2liaWxpdHkgUHJpbmNpcGxlOiBvbmx5IGhhbmRsZXMgcm91dGluZyBBUEkgY2FsbHMuXG4gKiBGb2xsb3dzIERlcGVuZGVuY3kgSW52ZXJzaW9uIFByaW5jaXBsZTogZGVwZW5kcyBvbiBhYnN0cmFjdGlvbnMgKGZldGNoKS5cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIExhdExuZyB7XG4gIGxhdDogbnVtYmVyO1xuICBsbmc6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVJlcXVlc3Qge1xuICBvcmlnaW46IExhdExuZztcbiAgZGVzdGluYXRpb246IExhdExuZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVByb3BlcnRpZXMge1xuICBkaXN0YW5jZTogbnVtYmVyO1xuICBkdXJhdGlvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlR2VvbWV0cnkge1xuICB0eXBlOiAnTGluZVN0cmluZyc7XG4gIGNvb3JkaW5hdGVzOiBudW1iZXJbXVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlRmVhdHVyZSB7XG4gIHR5cGU6ICdGZWF0dXJlJztcbiAgcHJvcGVydGllczogUm91dGVQcm9wZXJ0aWVzO1xuICBnZW9tZXRyeTogUm91dGVHZW9tZXRyeTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVJlc3BvbnNlIHtcbiAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJztcbiAgZmVhdHVyZXM6IFJvdXRlRmVhdHVyZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlRXJyb3Ige1xuICBlcnJvcjogc3RyaW5nO1xufVxuXG4vKipcbiAqIFNlcnZpY2UgZm9yIGZldGNoaW5nIHJvdXRpbmcgaW5mb3JtYXRpb24gZnJvbSBiYWNrZW5kIEFQSS5cbiAqIEltcGxlbWVudHMgY2FjaGluZyB0byByZWR1Y2UgQVBJIGNhbGxzIGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICogRm9sbG93cyBPcGVuL0Nsb3NlZCBQcmluY2lwbGU6IGV4dGVuc2libGUgZm9yIG5ldyByb3V0aW5nIGZlYXR1cmVzLlxuICovXG5leHBvcnQgY2xhc3MgUm91dGluZ0FwaVNlcnZpY2Uge1xuICBwcml2YXRlIGNhY2hlOiBNYXA8c3RyaW5nLCBSb3V0ZVJlc3BvbnNlPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBiYXNlVXJsOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYmFzZVVybDogc3RyaW5nID0gJy9hcGknKSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcm91dGUgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgKiBSZXR1cm5zIGNhY2hlZCByZXN1bHQgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmV0Y2hlcyBmcm9tIEFQSS5cbiAgICogRm9sbG93cyBTdHJhdGVneSBQYXR0ZXJuOiBjYW4gYmUgZXh0ZW5kZWQgd2l0aCBkaWZmZXJlbnQgcm91dGluZyBzdHJhdGVnaWVzLlxuICAgKi9cbiAgYXN5bmMgZ2V0Um91dGUob3JpZ2luOiBMYXRMbmcsIGRlc3RpbmF0aW9uOiBMYXRMbmcpOiBQcm9taXNlPFJvdXRlUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY3JlYXRlQ2FjaGVLZXkob3JpZ2luLCBkZXN0aW5hdGlvbik7XG4gICAgXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpITtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L3JvdXRlc2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YTogUm91dGVFcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVEYXRhOiBSb3V0ZVJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICAvLyBDYWNoZSBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICB0aGlzLmNhY2hlLnNldChjYWNoZUtleSwgcm91dGVEYXRhKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJvdXRlRGF0YTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByb3V0ZTonLCBlcnJvcik7XG4gICAgICAvLyBSZXR1cm4gZmFsbGJhY2sgcm91dGUgKHN0cmFpZ2h0IGxpbmUpXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWxsYmFja1JvdXRlKG9yaWdpbiwgZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgcm91dGUgY2FjaGUgKHVzZWZ1bCBmb3IgdGVzdGluZykuXG4gICAqL1xuICBjbGVhckNhY2hlKCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgY2FjaGUga2V5IGZyb20gY29vcmRpbmF0ZXMuXG4gICAqIEZvbGxvd3MgVmFsdWUgT2JqZWN0IHBhdHRlcm46IGltbXV0YWJsZSBrZXkgZ2VuZXJhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQ2FjaGVLZXkob3JpZ2luOiBMYXRMbmcsIGRlc3RpbmF0aW9uOiBMYXRMbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtvcmlnaW4ubGF0LnRvRml4ZWQoNil9LCR7b3JpZ2luLmxuZy50b0ZpeGVkKDYpfS0+JHtkZXN0aW5hdGlvbi5sYXQudG9GaXhlZCg2KX0sJHtkZXN0aW5hdGlvbi5sbmcudG9GaXhlZCg2KX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbXBsZSBzdHJhaWdodC1saW5lIGZhbGxiYWNrIHJvdXRlIHdoZW4gQVBJIGZhaWxzLlxuICAgKiBGb2xsb3dzIEZhbGxiYWNrIFN0cmF0ZWd5IHBhdHRlcm4uXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUZhbGxiYWNrUm91dGUob3JpZ2luOiBMYXRMbmcsIGRlc3RpbmF0aW9uOiBMYXRMbmcpOiBSb3V0ZVJlc3BvbnNlIHtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlSGF2ZXJzaW5lRGlzdGFuY2Uob3JpZ2luLCBkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgZHVyYXRpb24gPSBkaXN0YW5jZSAvIDEzLjg5OyAvLyBBc3N1bWUgNTAga20vaCA9IDEzLjg5IG0vcyBhdmVyYWdlIHNwZWVkXG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICBbb3JpZ2luLmxhdCwgb3JpZ2luLmxuZ10sXG4gICAgICAgICAgICAgIFtkZXN0aW5hdGlvbi5sYXQsIGRlc3RpbmF0aW9uLmxuZ10sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyB1c2luZyBIYXZlcnNpbmUgZm9ybXVsYS5cbiAgICogUmV0dXJucyBkaXN0YW5jZSBpbiBtZXRlcnMuXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZUhhdmVyc2luZURpc3RhbmNlKG9yaWdpbjogTGF0TG5nLCBkZXN0aW5hdGlvbjogTGF0TG5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBSID0gNjM3MTAwMDsgLy8gRWFydGggcmFkaXVzIGluIG1ldGVyc1xuICAgIGNvbnN0IGRMYXQgPSB0aGlzLnRvUmFkaWFucyhkZXN0aW5hdGlvbi5sYXQgLSBvcmlnaW4ubGF0KTtcbiAgICBjb25zdCBkTG5nID0gdGhpcy50b1JhZGlhbnMoZGVzdGluYXRpb24ubG5nIC0gb3JpZ2luLmxuZyk7XG4gICAgY29uc3QgYSA9IE1hdGguc2luKGRMYXQgLyAyKSAqIE1hdGguc2luKGRMYXQgLyAyKSArXG4gICAgICAgICAgICAgIE1hdGguY29zKHRoaXMudG9SYWRpYW5zKG9yaWdpbi5sYXQpKSAqIE1hdGguY29zKHRoaXMudG9SYWRpYW5zKGRlc3RpbmF0aW9uLmxhdCkpICpcbiAgICAgICAgICAgICAgTWF0aC5zaW4oZExuZyAvIDIpICogTWF0aC5zaW4oZExuZyAvIDIpO1xuICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICAgIHJldHVybiBSICogYztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAgICovXG4gIHByaXZhdGUgdG9SYWRpYW5zKGRlZ3JlZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MCk7XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlIGZvciB0aGUgYXBwbGljYXRpb25cbmV4cG9ydCBjb25zdCByb3V0aW5nQXBpU2VydmljZSA9IG5ldyBSb3V0aW5nQXBpU2VydmljZSgpO1xuIl0sInZlcnNpb24iOjN9